<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>–†–∏—Å–æ–≤–∞–ª–∫–∞ ‚Äî WebApp</title>
<style>
  :root{ --bg:#fafafa; --accent:#6aa6ff; --muted:#666; }
  html,body{ height:100%; margin:0; background:var(--bg); font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto; -webkit-font-smoothing:antialiased; }
  .wrap{ max-width:940px; margin:10px auto; padding:10px; box-sizing:border-box; }
  header{ display:flex; flex-direction:column; gap:6px; margin-bottom:8px; }

  /* canvas stack */
  #canvasWrap{ position:relative; width:100%; border:1px solid #ddd; background:white; border-radius:8px; overflow:hidden; touch-action:none; }
  .layer{ position:absolute; left:0; top:0; width:100%; height:100%; display:block; }
  #interaction{ position:absolute; left:0; top:0; width:100%; height:100%; z-index:50; }

  canvas{ display:block; width:100%; height:100%; -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; background:transparent; }

  .controls{ display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; align-items:center; }
  .tool-btn{ min-width:44px; height:44px; padding:6px 10px; border-radius:8px; border:1px solid #ddd; background:white; display:flex; gap:6px; align-items:center; justify-content:center; cursor:pointer; font-size:14px; user-select:none; }
  .tool-btn:focus{ outline: none; }
  .tool-btn.active{ outline:2px solid var(--accent); box-shadow:0 2px 6px rgba(100,150,255,0.12); }
  .tool-btn.flash{ outline:2px solid var(--accent); box-shadow:0 2px 6px rgba(100,150,255,0.18); }
  label{ font-size:13px; color:#333; display:flex; gap:6px; align-items:center; }
  input[type="range"]{ width:120px; }
  .right{ display:flex; gap:8px; margin-left:auto; align-items:center; flex-wrap:wrap; }
  #status{ font-size:13px; color:var(--muted); min-width:120px; }
  #cursorPreview{ position:absolute; pointer-events:none; transform:translate(-50%,-50%); display:none; border-radius:50%; box-shadow: 0 0 0 1px rgba(0,0,0,0.12) inset; z-index:40; }

  .palette-wrap{ display:flex; gap:12px; align-items:flex-start; margin-top:12px; flex-wrap:wrap; }
  #paletteCanvas{ width:160px; height:120px; border-radius:6px; border:1px solid #ddd; touch-action:none; }
  .color-controls{ display:flex; flex-direction:column; gap:6px; font-size:13px; }
  .rgb-row{ display:flex; gap:6px; align-items:center; }

  /* layer list */
  .layers-row{ display:flex; gap:8px; align-items:center; }
  .layer-btn{ padding:6px 8px; border-radius:6px; border:1px solid #ddd; background:#fff; cursor:pointer; }
  .layer-btn.active{ background:#eef6ff; outline:2px solid var(--accent); }
  .small{ font-size:12px; padding:4px 8px; }

  @media (max-width:800px){ .controls{ gap:6px; } .right{ margin-left:0; width:100%; justify-content:space-between; } input[type="range"]{ width:140px; } .palette-wrap{ gap:8px; } }
  .flash { transition: box-shadow .12s, outline .12s; }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h3>üé® –ú–∏–Ω–∏-—Ä–∏—Å–æ–≤–∞–ª–∫–∞</h3>
    <div style="font-size:13px;color:var(--muted);">–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã: –∫–∏—Å—Ç—å, –∫–∞—Ä–∞–Ω–¥–∞—à, –º–∞—Ä–∫–µ—Ä, –∑–∞–ª–∏–≤–∫–∞, –ª–∞—Å—Ç–∏–∫ ‚Äî –∞–¥–∞–ø—Ç–∏—Ä–æ–≤–∞–Ω–æ –ø–æ–¥ –º–æ–±–∏–ª—å–Ω—ã–µ. –ï—Å—Ç—å 5 —Å–ª–æ—ë–≤, Undo/Redo.</div>
  </header>

  <div id="canvasWrap" aria-label="–†–∏—Å–æ–≤–∞–ª—å–Ω—ã–π —Ö–æ–ª—Å—Ç" data-no-scroll>
    <!-- 5 layers stacked -->
    <canvas id="layer0" class="layer" width="800" height="800" aria-label="–°–ª–æ–π 1"></canvas>
    <canvas id="layer1" class="layer" width="800" height="800" aria-label="–°–ª–æ–π 2"></canvas>
    <canvas id="layer2" class="layer" width="800" height="800" aria-label="–°–ª–æ–π 3"></canvas>
    <canvas id="layer3" class="layer" width="800" height="800" aria-label="–°–ª–æ–π 4"></canvas>
    <canvas id="layer4" class="layer" width="800" height="800" aria-label="–°–ª–æ–π 5"></canvas>
    <!-- interaction canvas captures pointer input and is not drawn to directly -->
    <canvas id="interaction" class="layer" width="800" height="800" aria-hidden="true"></canvas>
    <div id="cursorPreview" aria-hidden="true"></div>
  </div>

  <div class="controls" aria-hidden="false">
    <div class="row" style="display:flex;gap:8px;align-items:center;">
      <button class="tool-btn active" data-tool="brush">üñåÔ∏è –ö–∏—Å—Ç—å</button>
      <button class="tool-btn" data-tool="pencil">‚úèÔ∏è –ö–∞—Ä–∞–Ω–¥–∞—à</button>
      <button class="tool-btn" data-tool="marker">üñçÔ∏è –ú–∞—Ä–∫–µ—Ä</button>
      <button class="tool-btn" data-tool="fill">ü™£ –ó–∞–ª–∏–≤–∫–∞</button>
      <button class="tool-btn" data-tool="eraser">üßΩ –õ–∞—Å—Ç–∏–∫</button>
    </div>

    <div class="row" style="align-items:center;">
      <label style="white-space:nowrap;">–†–∞–∑–º–µ—Ä: <input id="size" type="range" min="1" max="120" value="8"></label>
      <label style="white-space:nowrap;">–ù–µ–ø—Ä–æ–∑—Ä.: <input id="alpha" type="range" min="0.05" max="1" step="0.05" value="1"></label>
    </div>

    <div class="layers-row">
      <!-- layer buttons -->
      <div id="layerButtons"></div>
      <button class="tool-btn small" id="undo">‚Ü∂ Undo</button>
      <button class="tool-btn small" id="redo">‚Ü∑ Redo</button>
    </div>

    <div class="right">
      <div style="display:flex; gap:8px; align-items:center;">
        <button class="tool-btn" id="clear">–û—á–∏—Å—Ç–∏—Ç—å</button>
        <button class="tool-btn" id="download">–°–∫–∞—á–∞—Ç—å PNG</button>
      </div>

      <div style="display:flex; gap:8px; align-items:center;">
        Telegram chat_id: <input id="chat_id" placeholder="123456789" style="width:110px; padding:6px; border-radius:6px; border:1px solid #ddd;">
        <button class="tool-btn" id="send">–û—Ç–ø—Ä–∞–≤–∏—Ç—å –≤ —á–∞—Ç</button>
      </div>
    </div>
  </div>

  <div class="palette-wrap">
    <canvas id="paletteCanvas" width="160" height="120" data-no-scroll></canvas>
    <div class="color-controls">
      <div style="font-size:13px;color:#333;font-weight:600;">–í—ã–±–æ—Ä —Ü–≤–µ—Ç–∞</div>
      <div style="display:flex; gap:8px; align-items:center;">
        <input id="hexInput" type="text" maxlength="7" style="width:96px; padding:6px; border-radius:6px; border:1px solid #ddd;" placeholder="#rrggbb">
        <div id="preview" style="width:34px;height:34px;border-radius:6px;border:1px solid #ddd;"></div>
      </div>
      <div class="rgb-row">
        R <input id="r" type="number" min="0" max="255" style="width:60px; padding:6px; border-radius:6px; border:1px solid #ddd;">
        G <input id="g" type="number" min="0" max="255" style="width:60px; padding:6px; border-radius:6px; border:1px solid #ddd;">
        B <input id="b" type="number" min="0" max="255" style="width:60px; padding:6px; border-radius:6px; border:1px solid #ddd;">
      </div>
    </div>
  </div>

  <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
    <div id="status">–ì–æ—Ç–æ–≤–æ ‚Äî –≤—ã–±–µ—Ä–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –∏ —Ä–∏—Å—É–π.</div>
  </div>
</div>

<script>
/* ---------- Helpers ---------- */
const $ = s => document.querySelector(s);
const $$ = s => Array.from(document.querySelectorAll(s));
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function hexToRgb(hex){ if(!hex) return [0,0,0]; if(hex[0]==='#') hex = hex.slice(1); if(hex.length===3) hex = hex.split('').map(c=>c+c).join(''); const n = parseInt(hex,16); return [(n>>16)&255, (n>>8)&255, n&255]; }
function rgbToHex(r,g,b){ return '#'+[r,g,b].map(x=>x.toString(16).padStart(2,'0')).join(''); }
function flashBtn(btn){ if(!btn) return; btn.classList.add('flash'); setTimeout(()=> btn.classList.remove('flash'), 200); }

/* ---------- Elements & state ---------- */
const canvasWrap = $('#canvasWrap');
const interaction = $('#interaction');
const layerIds = ['layer0','layer1','layer2','layer3','layer4'];
const layers = layerIds.map(id => document.getElementById(id));
const ctxs = layers.map(l => l.getContext('2d', { willReadFrequently: true }));
const interactionCtx = interaction.getContext('2d');
const cursorPreview = $('#cursorPreview');
const palette = $('#paletteCanvas');
const pctx = palette.getContext('2d');
const preview = $('#preview');
const hexInput = $('#hexInput');
const rIn = $('#r'), gIn = $('#g'), bIn = $('#b');
const sizeInp = $('#size'), alphaInp = $('#alpha');
const status = $('#status');

let activeLayer = 0; // index 0..4
let tool = 'brush';
let drawing = false;
let last = {x:0,y:0};
let pointerId = null;
let currentColor = '#000000';

// Per-layer history stacks (dataURLs). Keep reasonable limit.
const history = Array.from({length:5}, ()=>({undos: [], redos: []}));
const HISTORY_LIMIT = 40;

/* ---------- Layer UI ---------- */
const layerButtonsContainer = $('#layerButtons');
function buildLayerButtons(){
  layerButtonsContainer.innerHTML = '';
  for(let i=4;i>=0;i--){ // show top layer first
    const btn = document.createElement('button');
    btn.className = 'layer-btn';
    btn.textContent = `L${i+1}`;
    btn.dataset.idx = i;
    btn.addEventListener('click', ()=>{
      flashBtn(btn);
      setActiveLayer(parseInt(btn.dataset.idx));
    });
    // visibility toggle
    const eye = document.createElement('button');
    eye.className = 'layer-btn small';
    eye.textContent = 'üëÅÔ∏è';
    eye.dataset.idx = i;
    eye.addEventListener('click', (ev)=>{ ev.stopPropagation(); const idx = parseInt(eye.dataset.idx); const vis = layers[idx].style.display !== 'none'; layers[idx].style.display = vis ? 'none' : 'block'; flashBtn(eye); });
    const wrapper = document.createElement('div');
    wrapper.style.display = 'flex'; wrapper.style.gap='6px'; wrapper.style.alignItems='center';
    wrapper.appendChild(btn); wrapper.appendChild(eye);
    layerButtonsContainer.appendChild(wrapper);
  }
}
buildLayerButtons();
function setActiveLayer(idx){ activeLayer = idx; // highlight correct btn
  $$('.layer-btn').forEach(b=> b.classList.toggle('active', parseInt(b.dataset.idx)===idx));
  status.textContent = `–°–ª–æ–π ${idx+1}`;
}
setActiveLayer(0);

/* ---------- Canvas sizing (square) ---------- */
function fitAll(){
  // compute target square size based on container width
  const w = Math.max(280, Math.min(1100, Math.round(canvasWrap.clientWidth)));
  // Fix container height so that CSS height:100% on canvases has a reference
  canvasWrap.style.height = w + 'px';

  layers.forEach((lv)=>{
    const tmp = document.createElement('canvas'); tmp.width = lv.width; tmp.height = lv.height; tmp.getContext('2d').drawImage(lv,0,0);
    // set logical size to square
    lv.width = w; lv.height = w;
    // ensure CSS fills container
    lv.style.width = '100%';
    lv.style.height = '100%';
    const c = lv.getContext('2d');
    c.clearRect(0,0,lv.width,lv.height);
    // draw scaled old content
    c.drawImage(tmp,0,0,tmp.width,tmp.height,0,0,lv.width,lv.height);
  });

  // interaction canvas: same treatment
  const ttmp = document.createElement('canvas'); ttmp.width = interaction.width; ttmp.height = interaction.height; ttmp.getContext('2d').drawImage(interaction,0,0);
  interaction.width = w; interaction.height = w;
  interaction.style.width = '100%';
  interaction.style.height = '100%';
  interaction.getContext('2d').clearRect(0,0,interaction.width,interaction.height);
}
window.addEventListener('resize', fitAll);
fitAll();

/* ---------- Cursor preview ---------- */
function updateCursorPreview(){
  const sz = Math.max(4, parseInt(sizeInp.value,10) || 8);
  cursorPreview.style.width = sz + 'px'; cursorPreview.style.height = sz + 'px'; cursorPreview.style.borderRadius = '50%'; cursorPreview.style.display = 'none'; cursorPreview.style.boxSizing = 'border-box'; cursorPreview.style.background = (tool === 'eraser') ? 'transparent' : currentColor; cursorPreview.style.opacity = (tool === 'eraser') ? '0.18' : Math.max(0.12, parseFloat(alphaInp.value) || 1); cursorPreview.style.border = (tool === 'eraser') ? '1px dashed rgba(0,0,0,0.35)' : '1px solid rgba(0,0,0,0.08)'; }
updateCursorPreview();

/* ---------- Tool handling ---------- */
function setActiveTool(t){ tool = t; $$('.tool-btn').forEach(b=>b.classList.toggle('active', b.dataset.tool===t)); updateCursorPreview(); status.textContent = `–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç: ${t}`; }
$$('.tool-btn[data-tool]').forEach(btn=> btn.addEventListener('click', ()=>{ flashBtn(btn); setActiveTool(btn.dataset.tool); }));

/* ---------- History (undo/redo) ---------- */
function pushHistory(layerIdx){ try{
  const data = layers[layerIdx].toDataURL();
  history[layerIdx].undos.push(data);
  if(history[layerIdx].undos.length>HISTORY_LIMIT) history[layerIdx].undos.shift();
  history[layerIdx].redos = []; // clear redo on new action
} catch(e){ console.error('pushHistory', e); }}
function restoreDataURLToLayer(layerIdx, dataURL){ const img = new Image(); img.onload = ()=>{ const c = layers[layerIdx].getContext('2d'); c.clearRect(0,0,layers[layerIdx].width,layers[layerIdx].height); c.drawImage(img,0,0,layers[layerIdx].width,layers[layerIdx].height); }; img.src = dataURL; }
function undo(){ const h = history[activeLayer]; if(!h || h.undos.length===0) return; const last = h.undos.pop(); h.redos.push(last); const prev = h.undos[h.undos.length-1] || null; if(prev){ restoreDataURLToLayer(activeLayer, prev); } else { // clear layer
  ctxs[activeLayer].clearRect(0,0,layers[activeLayer].width,layers[activeLayer].height);
 }
 flashBtn($('#undo'));
}
function redo(){ const h = history[activeLayer]; if(!h || h.redos.length===0) return; const next = h.redos.pop(); h.undos.push(next); restoreDataURLToLayer(activeLayer, next); flashBtn($('#redo')); }
$('#undo').addEventListener('click', ()=>{ undo(); });
$('#redo').addEventListener('click', ()=>{ redo(); });

/* ---------- Drawing helpers (draw to active layer ctx) ---------- */
function getCanvasPosFromClient(clientX, clientY){ const rect = interaction.getBoundingClientRect(); return { x: Math.round((clientX - rect.left) * (interaction.width / rect.width)), y: Math.round((clientY - rect.top) * (interaction.height / rect.height)) }; }
function setCtxForToolForLayer(layerIdx){ const ctx = ctxs[layerIdx]; ctx.setTransform(1,0,0,1,0,0); ctx.lineJoin='round'; ctx.lineCap='round'; ctx.globalCompositeOperation = (tool==='eraser')?'destination-out':'source-over'; if(tool==='marker'){ ctx.lineWidth = Math.max(6, parseInt(sizeInp.value,10)*1.6); ctx.globalAlpha = Math.max(0.12, parseFloat(alphaInp.value)*0.6); } else if(tool==='pencil'){ ctx.lineWidth = Math.max(1, Math.round(parseInt(sizeInp.value,10)*0.6)); ctx.globalAlpha = Math.max(0.08, parseFloat(alphaInp.value)*0.95); } else { ctx.lineWidth = Math.max(1, parseInt(sizeInp.value,10)); ctx.globalAlpha = parseFloat(alphaInp.value); } ctx.strokeStyle = (tool==='eraser')?'rgba(0,0,0,1)':currentColor; }
function drawLineOnLayer(layerIdx,x1,y1,x2,y2){ const c = ctxs[layerIdx]; c.beginPath(); c.moveTo(x1,y1); c.lineTo(x2,y2); c.stroke(); }
function drawPencilOnLayer(layerIdx,x1,y1,x2,y2){ const c = ctxs[layerIdx]; const pencilAlpha = Math.max(0.15, parseFloat(alphaInp.value)*0.9); const steps = Math.max(6, Math.floor(Math.hypot(x2-x1,y2-y1)/2)); for(let i=0;i<steps;i++){ const t=i/steps; const cx = x1 + (x2-x1)*t + (Math.random()-0.5)*1.8; const cy = y1 + (y2-y1)*t + (Math.random()-0.5)*1.8; c.globalAlpha = pencilAlpha * (0.7 + Math.random()*0.6); c.beginPath(); c.moveTo(cx,cy); const nx = cx + (Math.random()-0.5)*1.2; const ny = cy + (Math.random()-0.5)*1.2; c.lineTo(nx,ny); c.stroke(); } }

/* flood fill same as before but operates on active layer */
function floodFillLayer(layerIdx,startX,startY,fillRGBA){ try{ const layer = layers[layerIdx]; const c = ctxs[layerIdx]; const w=layer.width,h=layer.height; const img = c.getImageData(0,0,w,h); const data = img.data; const getIdx=(x,y)=>(y*w+x)*4; const t=getIdx(startX,startY); const tr=data[t],tg=data[t+1],tb=data[t+2],ta=data[t+3]; if(tr===fillRGBA[0]&&tg===fillRGBA[1]&&tb===fillRGBA[2]&&ta===fillRGBA[3]) return; const stack=[[startX,startY]]; while(stack.length){ const [x,y]=stack.pop(); let nx=x; while(nx>=0){ const i=getIdx(nx,y); if(data[i]===tr&&data[i+1]===tg&&data[i+2]===tb&&data[i+3]===ta) nx--; else break; } nx++; let spanUp=false, spanDown=false; while(nx<w){ const i=getIdx(nx,y); if(!(data[i]===tr&&data[i+1]===tg&&data[i+2]===tb&&data[i+3]===ta)) break; data[i]=fillRGBA[0]; data[i+1]=fillRGBA[1]; data[i+2]=fillRGBA[2]; data[i+3]=fillRGBA[3]; if(y>0){ const iu=getIdx(nx,y-1); if(data[iu]===tr&&data[iu+1]===tg&&data[iu+2]===tb&&data[iu+3]===ta){ if(!spanUp){ stack.push([nx,y-1]); spanUp=true; } } else spanUp=false; } if(y<h-1){ const idn=getIdx(nx,y+1); if(data[idn]===tr&&data[idn+1]===tg&&data[idn+2]===tb&&data[idn+3]===ta){ if(!spanDown){ stack.push([nx,y+1]); spanDown=true; } } else spanDown=false; } nx++; } } c.putImageData(img,0,0); }catch(e){ console.error('fill error',e); } }

/* ---------- Pointer / touch handling on interaction canvas ---------- */
function onPointerDown(clientX, clientY, pId){ const pos = getCanvasPosFromClient(clientX, clientY); if(tool==='fill'){ const rgba = hexToRgb(currentColor); rgba.push(Math.round(parseFloat(alphaInp.value)*255)); // push history before change
  pushHistory(activeLayer); floodFillLayer(activeLayer,pos.x,pos.y,rgba); status.textContent='–ó–∞–ª–∏–≤–∫–∞ –ø—Ä–∏–º–µ–Ω–µ–Ω–∞'; return; }
  // start drawing
  drawing=true; last.x=pos.x; last.y=pos.y; pointerId=pId; // prepare ctx
  setCtxForToolForLayer(activeLayer); // ensure tiny dot on tap
  const cctx = ctxs[activeLayer]; cctx.beginPath(); cctx.moveTo(last.x,last.y); cctx.lineTo(last.x+0.01,last.y+0.01); cctx.stroke(); cursorPreview.style.display='block'; moveCursorPreviewPosition(clientX,clientY);
}
function onPointerMove(clientX, clientY, pId){ moveCursorPreviewPosition(clientX,clientY); if(!drawing) return; if(pointerId!==null && pId!==pointerId) return; const pos = getCanvasPosFromClient(clientX, clientY); if(tool==='pencil') drawPencilOnLayer(activeLayer,last.x,last.y,pos.x,pos.y); else drawLineOnLayer(activeLayer,last.x,last.y,pos.x,pos.y); last.x=pos.x; last.y=pos.y; }
function onPointerUp(clientX, clientY, pId){ if(drawing){ // push history snapshot
    try{ pushHistory(activeLayer); }catch(e){console.warn(e);} }
  drawing=false; pointerId=null; cursorPreview.style.display='none'; }

// attach events to interaction canvas
interaction.addEventListener('pointerdown', (e)=>{ e.preventDefault(); try{ interaction.setPointerCapture(e.pointerId); }catch{} onPointerDown(e.clientX,e.clientY,e.pointerId); });
interaction.addEventListener('pointermove', (e)=>{ onPointerMove(e.clientX,e.clientY,e.pointerId); });
interaction.addEventListener('pointerup', (e)=>{ try{ interaction.releasePointerCapture(e.pointerId); }catch{} onPointerUp(e.clientX,e.clientY,e.pointerId); });
interaction.addEventListener('pointercancel', (e)=>{ try{ interaction.releasePointerCapture(e.pointerId); }catch{} onPointerUp(e.clientX,e.clientY,e.pointerId); });
// touch fallback
interaction.addEventListener('touchstart',(e)=>{ const t=e.touches[0]; onPointerDown(t.clientX,t.clientY,'touch'); e.preventDefault(); },{passive:false});
interaction.addEventListener('touchmove',(e)=>{ const t=e.touches[0]; onPointerMove(t.clientX,t.clientY,'touch'); e.preventDefault(); },{passive:false});
interaction.addEventListener('touchend',(e)=>{ onPointerUp(0,0,'touch'); },{passive:false});

function moveCursorPreviewPosition(clientX, clientY){ const rect=interaction.getBoundingClientRect(); const cssX = clientX - rect.left; const cssY = clientY - rect.top; cursorPreview.style.left = cssX + 'px'; cursorPreview.style.top = cssY + 'px'; const displaySize = Math.max(4, parseInt(sizeInp.value,10) * (rect.width / interaction.width)); cursorPreview.style.width = displaySize + 'px'; cursorPreview.style.height = displaySize + 'px'; cursorPreview.style.border = tool==='eraser' ? '1px dashed rgba(0,0,0,0.35)' : '1px solid rgba(0,0,0,0.1)'; cursorPreview.style.background = (tool==='eraser') ? 'transparent' : currentColor; cursorPreview.style.opacity = (tool==='eraser') ? '0.18' : Math.max(0.12, parseFloat(alphaInp.value) || 1); }

// prevent page scroll while touching interactive areas (canvas, palette)
document.addEventListener('touchmove', function(e){ const t = e.target; if(t && (t.closest('[data-no-scroll]') || t.closest('#paletteCanvas') || t.closest('.palette-wrap') || t.closest('.tool-btn'))){ e.preventDefault(); } }, { passive:false });

/* ---------- Clear / Download / Send ---------- */
$('#clear').addEventListener('click', ()=>{ // clear only active layer
  pushHistory(activeLayer);
  ctxs[activeLayer].clearRect(0,0,layers[activeLayer].width,layers[activeLayer].height);
  status.textContent = '–°–ª–æ–π –æ—á–∏—â–µ–Ω'; flashBtn($('#clear'));
});

function downloadComposite(){ const w = layers[0].width, h = layers[0].height; const tmp = document.createElement('canvas'); tmp.width = w; tmp.height = h; const tctx = tmp.getContext('2d'); // draw layers in order
  for(let i=0;i<layers.length;i++){ if(layers[i].style.display==='none') continue; tctx.drawImage(layers[i],0,0); }
  if(tmp.toBlob){ tmp.toBlob((blob)=>{ const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'drawing.png'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); status.textContent='–°–∫–∞—á–∞–Ω–æ'; },'image/png'); } else { const data = tmp.toDataURL('image/png'); const a = document.createElement('a'); a.href = data; a.download='drawing.png'; a.click(); status.textContent='–°–∫–∞—á–µ–Ω–æ (fallback)'; } }
$('#download').addEventListener('click', ()=>{ downloadComposite(); flashBtn($('#download')); });

$('#send').addEventListener('click', async ()=>{ // composite and send
  const w = layers[0].width, h = layers[0].height; const tmp = document.createElement('canvas'); tmp.width = w; tmp.height = h; const tctx = tmp.getContext('2d'); for(let i=0;i<layers.length;i++){ if(layers[i].style.display==='none') continue; tctx.drawImage(layers[i],0,0); }
  const img = tmp.toDataURL('image/png'); const chat_id = $('#chat_id').value.trim(); if(!chat_id){ status.textContent='–í–≤–µ–¥–∏—Ç–µ chat_id'; return; } status.textContent='–û—Ç–ø—Ä–∞–≤–∫–∞‚Ä¶'; try{ const res = await fetch('/upload', { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify({ image: img, chat_id: chat_id }) }); const j = await res.json(); if(res.ok){ status.textContent = 'OK: ' + (j.status || 'sent'); } else { status.textContent = '–û—à–∏–±–∫–∞: ' + JSON.stringify(j); } }catch(e){ status.textContent = '–û—à–∏–±–∫–∞ —Å–µ—Ç–∏: ' + e.message; } });

/* ---------- Palette ---------- */
function drawPalette(){ const w = palette.width = Math.max(160, Math.round(palette.clientWidth)); const h = palette.height = 120; const hueGrad = pctx.createLinearGradient(0,0,w,0); hueGrad.addColorStop(0,'#ff0000'); hueGrad.addColorStop(0.17,'#ffff00'); hueGrad.addColorStop(0.33,'#00ff00'); hueGrad.addColorStop(0.5,'#00ffff'); hueGrad.addColorStop(0.66,'#0000ff'); hueGrad.addColorStop(0.82,'#ff00ff'); hueGrad.addColorStop(1,'#ff0000'); pctx.fillStyle = hueGrad; pctx.fillRect(0,0,w,h); const g2 = pctx.createLinearGradient(0,0,0,h); g2.addColorStop(0,'rgba(255,255,255,1)'); g2.addColorStop(0.5,'rgba(255,255,255,0)'); g2.addColorStop(0.5,'rgba(0,0,0,0)'); g2.addColorStop(1,'rgba(0,0,0,0.6)'); pctx.fillStyle = g2; pctx.fillRect(0,0,w,h); }
drawPalette(); window.addEventListener('resize', drawPalette);

let isPalDown=false; function palettePointer(clientX,clientY){ const rect=palette.getBoundingClientRect(); const x=clamp(Math.round((clientX-rect.left)*(palette.width/rect.width)),0,palette.width-1); const y=clamp(Math.round((clientY-rect.top)*(palette.height/rect.height)),0,palette.height-1); const d=pctx.getImageData(x,y,1,1).data; const hex=rgbToHex(d[0],d[1],d[2]); currentColor=hex; hexInput.value=hex; rIn.value=d[0]; gIn.value=d[1]; bIn.value=d[2]; preview.style.background=hex; setCtxForToolForLayer(activeLayer); updateCursorPreview(); }
palette.addEventListener('pointerdown', (e)=>{ isPalDown=true; try{ palette.setPointerCapture(e.pointerId);}catch{} palettePointer(e.clientX,e.clientY); e.preventDefault(); });
palette.addEventListener('pointermove', (e)=>{ if(isPalDown) palettePointer(e.clientX,e.clientY); });
palette.addEventListener('pointerup', (e)=>{ isPalDown=false; try{ palette.releasePointerCapture(e.pointerId);}catch{} });
palette.addEventListener('pointercancel', ()=> isPalDown=false);
palette.addEventListener('touchstart',(e)=>{ const t=e.touches[0]; isPalDown=true; palettePointer(t.clientX,t.clientY); e.preventDefault(); },{passive:false});
palette.addEventListener('touchmove',(e)=>{ const t=e.touches[0]; if(isPalDown) palettePointer(t.clientX,t.clientY); e.preventDefault(); },{passive:false});
palette.addEventListener('touchend', (e)=>{ isPalDown=false; },{passive:false});

hexInput.addEventListener('change', ()=>{ const val=hexInput.value.trim(); const v=val.startsWith('#')?val:'#'+val; const [r,g,b]=hexToRgb(v); currentColor=v; preview.style.background=v; rIn.value=r; gIn.value=g; bIn.value=b; setCtxForToolForLayer(activeLayer); updateCursorPreview(); });
[rIn,gIn,bIn].forEach(inp=>inp.addEventListener('change', ()=>{ const r=clamp(parseInt(rIn.value||0,10),0,255); const g=clamp(parseInt(gIn.value||0,10),0,255); const b=clamp(parseInt(bIn.value||0,10),0,255); const hex=rgbToHex(r,g,b); currentColor=hex; hexInput.value=hex; preview.style.background=hex; setCtxForToolForLayer(activeLayer); updateCursorPreview(); })));

/* init */
(function initColorFields(){ const [r,g,b]=hexToRgb(currentColor); rIn.value=r; gIn.value=g; bIn.value=b; hexInput.value=currentColor; preview.style.background=currentColor; })();

/* keyboard */
document.addEventListener('keydown',(e)=>{ if(e.key==='b') setActiveTool('brush'); if(e.key==='p') setActiveTool('pencil'); if(e.key==='m') setActiveTool('marker'); if(e.key==='e') setActiveTool('eraser'); });

/* helper: push initial empty state for each layer */
layers.forEach((L,idx)=>{ try{ const d=L.toDataURL(); history[idx].undos.push(d); }catch(e){} });

status.textContent='–ì–æ—Ç–æ–≤–æ ‚Äî –≤—ã–±–µ—Ä–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –∏ —Ä–∏—Å—É–π.';
</script>
</body>
</html>
